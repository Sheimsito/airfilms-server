# üèóÔ∏è Arquitectura del Proyecto AirFilms Server

Este documento describe la arquitectura, patrones de dise√±o y decisiones t√©cnicas del backend de AirFilms.

---

## üìê Tabla de Contenidos

1. [Visi√≥n General](#-visi√≥n-general)
2. [Arquitectura en Capas](#-arquitectura-en-capas)
3. [Flujo de Datos](#-flujo-de-datos)
4. [Patrones de Dise√±o](#-patrones-de-dise√±o)
5. [Estructura de Carpetas](#-estructura-de-carpetas)
6. [Componentes Principales](#-componentes-principales)
7. [Base de Datos](#-base-de-datos)
8. [Decisiones T√©cnicas](#-decisiones-t√©cnicas)
9. [Escalabilidad](#-escalabilidad)

---

## üéØ Visi√≥n General

AirFilms Server es una API RESTful construida con **arquitectura en capas** que separa las responsabilidades en diferentes niveles, facilitando el mantenimiento, testing y escalabilidad.

### Principios Arquitect√≥nicos

- ‚úÖ **Separation of Concerns (SoC)**: Cada capa tiene una responsabilidad espec√≠fica
- ‚úÖ **Single Responsibility Principle (SRP)**: Cada clase/m√≥dulo tiene un prop√≥sito √∫nico
- ‚úÖ **Dependency Injection**: Las dependencias se inyectan, no se instancian
- ‚úÖ **DRY (Don't Repeat Yourself)**: C√≥digo reutilizable mediante abstracciones
- ‚úÖ **Type Safety**: TypeScript garantiza tipos en tiempo de compilaci√≥n

---

## üß± Arquitectura en Capas

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           CLIENT (Frontend/Mobile)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üï HTTPS
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         PRESENTATION LAYER (Express)         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   Routes ‚Üí Controllers ‚Üí Middleware   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üï
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  SERVICES LAYER             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  External Services Integration       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Email (Resend)                    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Movies API (TMDB, OMDB, etc.)     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ                                      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üï
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          DATA ACCESS LAYER (DAO)            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ    BaseDAO ‚Üí SpecificDAO ‚Üí Supabase  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üï
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         DATABASE (Supabase)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Descripci√≥n de Capas

#### 1. **Presentation Layer (Capa de Presentaci√≥n)**

**Responsabilidad:** Manejar las peticiones HTTP y respuestas.

**Componentes:**
- **Routes:** Definen los endpoints de la API
- **Controllers:** Procesan las peticiones y delegan la l√≥gica
- **Middleware:** Interceptan peticiones (autenticaci√≥n, validaci√≥n, manejo de errores)

**Ubicaci√≥n:** `src/routes/`, `src/controllers/`, `src/middleware/`

#### 2. **Business Logic & Services Layer (Capa de L√≥gica de Negocio y Servicios Externos)**

**Responsabilidad:** Integrar servicios externos y orquestar operaciones complejas.

**Componentes:**
- **External Services:** Integraciones con APIs y servicios de terceros
  - **Email Service (Resend):** Env√≠o de emails transaccionales (recuperaci√≥n de contrase√±a)
  - **Movies API Service:** Consumo de APIs de pel√≠culas (TMDB, OMDB, etc.) para obtener informaci√≥n de contenido multimedia NOTA: En investigaci√≥n

**Ubicaci√≥n:** `src/service/`
```

#### 3. **Data Access Layer (Capa de Acceso a Datos)**

**Responsabilidad:** Abstraer las operaciones de base de datos.

**Componentes:**
- **DAOs (Data Access Objects):** Encapsulan consultas a la base de datos
- **BaseDAO:** Clase gen√©rica con operaciones CRUD comunes
- **Specific DAOs:** Extienden BaseDAO con operaciones espec√≠ficas

**Ubicaci√≥n:** `src/dao/`

#### 4. **Database Layer (Capa de Base de Datos)**

**Responsabilidad:** Almacenar y gestionar datos persistentes.

**Tecnolog√≠a:** Supabase (PostgreSQL)

---

## üîÑ Flujo de Datos

### Ejemplo 1: Registro de Usuario

```
1. CLIENT
   ‚îî‚îÄ> POST /api/auth/register
       Body: { name, lastName, age, email, password }
          ‚Üì
2. ROUTE (routes/index.ts ‚Üí authRoutes.ts)
   ‚îî‚îÄ> router.post('/register', authController.register)
          ‚Üì
3. CONTROLLER (authController.ts)
   ‚îú‚îÄ> Valida campos requeridos (name, lastName, age, email, password)
   ‚îú‚îÄ> Valida formato de email (regex)
   ‚îú‚îÄ> Valida formato de contrase√±a (min 8 chars, may√∫scula, n√∫mero, especial)
   ‚îú‚îÄ> Verifica que el email no exista (userDAO.findByEmail)
   ‚îî‚îÄ> Llama a userDAO.create(userData)
          ‚Üì
4. DAO (userDAO.ts ‚Üí baseDAO.ts)
   ‚îú‚îÄ> userDAO.create() hashea la contrase√±a con bcrypt
   ‚îú‚îÄ> BaseDAO.create() ejecuta:
   ‚îÇ   ‚îî‚îÄ> supabase.from('users').insert([payload]).select('*').single()
   ‚îî‚îÄ> Retorna el usuario creado
          ‚Üì
5. DATABASE (Supabase)
   ‚îú‚îÄ> Valida constraints (unique email, not null, check constraints)
   ‚îú‚îÄ> Inserta registro con valores por defecto (isDeleted: false, timestamps)
   ‚îî‚îÄ> Retorna datos insertados
          ‚Üì
6. RESPONSE
   ‚îî‚îÄ> Controller env√≠a respuesta al cliente
       Status: 201 Created
       Body: { userId: "uuid" }
```

### Ejemplo 2: Recuperaci√≥n de Contrase√±a

```
1. CLIENT
   ‚îî‚îÄ> POST /api/auth/forgot-password
       Body: { email: "user@example.com" }
          ‚Üì
2. CONTROLLER (authController.forgotPassword)
   ‚îú‚îÄ> Busca usuario por email (userDAO.findByEmail)
   ‚îú‚îÄ> Si no existe: retorna 202 (por seguridad, no revelar si existe)
   ‚îú‚îÄ> Genera jwtid √∫nico (random string)
   ‚îú‚îÄ> Crea JWT con userId y jwtid, expiraci√≥n 1h
   ‚îú‚îÄ> Guarda jwtid en DB (userDAO.updateResetPasswordJti)
          ‚Üì
3. EXTERNAL SERVICE (resendService)
   ‚îú‚îÄ> Genera link: ${FRONTEND_URL}/reset-password?token=${resetToken}
   ‚îú‚îÄ> En desarrollo: env√≠a a email verificado (kealgri@gmail.com)
   ‚îú‚îÄ> En producci√≥n: env√≠a al email del usuario
   ‚îú‚îÄ> sendMail() usa Resend API
   ‚îî‚îÄ> Email: "Haz clic para restablecer tu contrase√±a"
          ‚Üì
4. CLIENT (Usuario hace click en el link)
   ‚îî‚îÄ> POST /api/auth/reset-password
       Body: { token: "jwt...", newPassword: "NewPass123!" }
          ‚Üì
5. CONTROLLER (authController.resetPassword)
   ‚îú‚îÄ> Verifica JWT (jwt.verify)
   ‚îú‚îÄ> Busca usuario (userDAO.findById)
   ‚îú‚îÄ> Verifica que user.resetPasswordJti === decoded.jti
   ‚îú‚îÄ> Valida nueva contrase√±a (min 8, may√∫scula, n√∫mero, especial)
   ‚îú‚îÄ> Invalida el token (updateResetPasswordJti con "")
   ‚îú‚îÄ> Actualiza contrase√±a hasheada (userDAO.updateById)
          ‚Üì
6. RESPONSE
   ‚îî‚îÄ> Status: 200 OK
       Body: { success: true, message: "Contrase√±a actualizada." }
```

### Ejemplo 3: Verificaci√≥n de Autenticaci√≥n

```
1. CLIENT
   ‚îî‚îÄ> GET /api/auth/verify-auth
       Headers: Authorization: Bearer <token> o Cookie: access_token
          ‚Üì
2. MIDDLEWARE (authenticateToken)
   ‚îú‚îÄ> Extrae token del header o cookie
   ‚îú‚îÄ> Verifica firma del JWT (jwt.verify)
   ‚îú‚îÄ> Verifica expiraci√≥n
   ‚îú‚îÄ> Inyecta user.userId en req.user
   ‚îî‚îÄ> Pasa al controlador
          ‚Üì
3. CONTROLLER (authController.verifyAuth)
   ‚îú‚îÄ> Lee req.user.userId (inyectado por middleware)
   ‚îî‚îÄ> Retorna informaci√≥n del usuario
          ‚Üì
4. RESPONSE
   ‚îî‚îÄ> Status: 200 OK
       Body: { success: true, user: { id: "uuid" } }

// Si el token es inv√°lido o expir√≥:
MIDDLEWARE ‚Üí 401 Unauthorized: { message: "No autorizado." }
```



---

## üé® Patrones de Dise√±o

### 1. **DAO Pattern (Data Access Object)**

Abstrae y encapsula todo el acceso a la fuente de datos.

**Ventajas:**
- Separa la l√≥gica de persistencia de la l√≥gica de negocio
- Facilita el cambio de base de datos sin afectar otras capas
- Permite testing mediante mocks

**Implementaci√≥n:**

```typescript
// Base gen√©rico
class BaseDAO<Row, Insert, Update> {
  async create(payload: Insert): Promise<Row> { }
  async findById(id: string): Promise<Row> { }
  async list(params): Promise<Paginated<Row>> { }
  async updateById(id: string, payload: Update): Promise<Row> { }
  async deleteById(id: string): Promise<boolean> { }
}

// Implementaci√≥n espec√≠fica
class UserDAO extends BaseDAO<UserRow, UserInsert, UserUpdate> {
  constructor() {
    super('users'); // nombre de la tabla
  }
  
  // M√©todos adicionales espec√≠ficos de usuarios
  async findByEmail(email: string): Promise<UserRow | null> { }
}
```

### 2. **Repository Pattern (impl√≠cito en DAO)**

Similar al DAO, pero m√°s orientado al dominio.

### 3. **Singleton Pattern**

El cliente de Supabase se instancia una sola vez:

```typescript
// supabaseClient.ts
export const supabase = createClient(...); // Una sola instancia

// Uso en m√∫ltiples archivos
import { supabase } from './lib/supabaseClient';
```

### 4. **MVC Pattern (Model-View-Controller)**

Aunque no hay "vistas" (es una API), seguimos una variante:
- **Model:** `src/types/database.ts` (tipos de datos)
- **Controller:** `src/controllers/`
- **"View":** JSON responses

**Nota:** No usamos carpeta `models/` porque con DAO Pattern los tipos est√°n centralizados en `types/database.ts`

### 5. **Middleware Pattern**

Interceptan peticiones antes de llegar al controlador:

```typescript
app.use(express.json());           // Parse JSON
app.use('/api/users', userRoutes); // Routing
app.use(errorHandler);             // Error handling
```

---

## üìÇ Estructura de Carpetas

```
src/
‚îú‚îÄ‚îÄ config/              # üîß Configuraci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ config.ts        # Variables de entorno centralizadas
‚îÇ   ‚îî‚îÄ‚îÄ server.ts        # Configuraci√≥n de Express (CORS, body parser, middlewares)
‚îÇ
‚îú‚îÄ‚îÄ controllers/         # üéÆ Controladores 
‚îÇ   ‚îú‚îÄ‚îÄ authController.ts   # Registro, login, logout, forgot/reset password, verify auth
‚îÇ   ‚îî‚îÄ‚îÄ userController.ts   # Perfil de usuario, actualizaci√≥n, soft delete
‚îÇ
‚îú‚îÄ‚îÄ dao/                 # üóÑÔ∏è Data Access Objects
‚îÇ   ‚îú‚îÄ‚îÄ baseDAO.ts       # DAO gen√©rico (CRUD + soft delete)
‚îÇ   ‚îî‚îÄ‚îÄ userDAO.ts       # DAO espec√≠fico de usuarios
‚îÇ
‚îú‚îÄ‚îÄ lib/                 # üìö Librer√≠as externas
‚îÇ   ‚îî‚îÄ‚îÄ supabaseClient.ts # Cliente de Supabase (tipado y gen√©rico)
‚îÇ
‚îú‚îÄ‚îÄ middleware/          # üõ°Ô∏è Middlewares
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts          # Autenticaci√≥n JWT + rate limiting
‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.ts  # Manejo centralizado de errores (Supabase, JWT, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ logger.ts        # Logger de peticiones HTTP
‚îÇ   ‚îî‚îÄ‚îÄ notFound.ts      # Manejo de rutas 404
‚îÇ
‚îú‚îÄ‚îÄ routes/              # üõ£Ô∏è Definici√≥n de rutas
‚îÇ   ‚îú‚îÄ‚îÄ index.ts         # Router principal que agrupa todas las rutas
‚îÇ   ‚îú‚îÄ‚îÄ authRoutes.ts    # Rutas de autenticaci√≥n (p√∫blicas)
‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.ts    # Rutas de usuario (protegidas)
‚îÇ
‚îú‚îÄ‚îÄ service/             # üåê Servicios externos e integraciones
‚îÇ   ‚îî‚îÄ‚îÄ resendService.ts # Servicio de emails (Resend API)
‚îÇ
‚îú‚îÄ‚îÄ types/               # üè∑Ô∏è Tipos TypeScript compartidos
‚îÇ   ‚îú‚îÄ‚îÄ database.ts      # Tipos de base de datos (Supabase) - Single Source of Truth
‚îÇ   ‚îî‚îÄ‚îÄ express.d.ts     # Extensiones de tipos de Express (AuthRequest)
‚îÇ
‚îî‚îÄ‚îÄ server.ts            # üåê Punto de entrada principal (HTTP server)
```

## üóÑÔ∏è Base de Datos

### Tecnolog√≠a: Supabase (PostgreSQL)

**Caracter√≠sticas:**
- Base de datos PostgreSQL gestionada
- Row Level Security (RLS)
- Realtime subscriptions
- API REST autom√°tica
- Storage para archivos

### Tipos de Base de Datos

Todos los tipos est√°n centralizados en `src/types/database.ts` como **single source of truth**.

```typescript
// types/database.ts
export interface Database {
  public: {
    Tables: {
      users: {
        Row: { /* campos de la tabla */ };
        Insert: { /* campos requeridos para insert */ };
        Update: { /* campos opcionales para update */ };
      };
    };
  };
}

// Helper types exportados
export type UserRow = Database['public']['Tables']['users']['Row'];
export type UserInsert = Database['public']['Tables']['users']['Insert'];
export type UserUpdate = Database['public']['Tables']['users']['Update'];
```

**Ventajas:**
- ‚úÖ Single source of truth
- ‚úÖ Puede generarse autom√°ticamente desde Supabase
- ‚úÖ No hay duplicaci√≥n de tipos
- ‚úÖ Consistencia garantizada

### Esquema de Base de Datos

#### Tabla: `users`

| Columna            | Tipo        | Descripci√≥n                      |
|--------------------|-------------|----------------------------------|
| id                 | UUID        | Primary Key (auto-generado)     |
| name               | VARCHAR     | Nombre del usuario               |
| lastName           | VARCHAR     | Apellido del usuario             |
| age                | INTEGER     | Edad del usuario                 |
| email              | VARCHAR     | Email √∫nico (unique constraint)  |
| password           | VARCHAR     | Contrase√±a (debe hashearse)      |
| resetPasswordJti   | VARCHAR     | Token para reset de contrase√±a   |
| isDeleted          | BOOLEAN     | Soft delete flag                 |
| createdAt          | TIMESTAMP   | Fecha de creaci√≥n                |
| updatedAt          | TIMESTAMP   | Fecha de √∫ltima actualizaci√≥n    |

### Conexi√≥n

```typescript
// Dos clientes seg√∫n necesidad:

// 1. Cliente tipado (para uso espec√≠fico)
export const supabase = createClient<Database>(url, key);

// 2. Cliente gen√©rico (para BaseDAO)
export const supabaseGeneric = createClient(url, key);
```

**¬øPor qu√© dos clientes?**
- El cliente tipado requiere que las tablas est√©n definidas en `Database`
- El `BaseDAO` es gen√©rico y trabaja con cualquier tabla
- Esto evita conflictos de tipos en TypeScript

---

## üß† Decisiones T√©cnicas

### 1. **TypeScript sobre JavaScript**

**Raz√≥n:** Type-safety, mejor DX, menos bugs en producci√≥n.

### 2. **ESM (ES Modules) en lugar de CommonJS**

**Configuraci√≥n:**
- `"type": "module"` en `package.json`
- `moduleResolution: "Node"` en `tsconfig.json`

**Ventajas:**
- Est√°ndar moderno de JavaScript
- Mejor tree-shaking
- Sintaxis import/export consistente

### 3. **Services para Integraciones Externas**

**Raz√≥n:**
- Separar la l√≥gica de integraci√≥n con APIs externas
- Facilita el testing mediante mocks
- Permite cambiar proveedores sin afectar controladores
- Centraliza la configuraci√≥n de servicios externos

**Ejemplos de servicios:**
- **Email Service (Resend):** Env√≠o de emails transaccionales
- **Movies API Service (TMDB):** Obtenci√≥n de informaci√≥n de pel√≠culas
- **Storage Service (Supabase Storage):** Gesti√≥n de archivos

**Ventajas:**
- Un solo lugar para cambiar la API de pel√≠culas (de TMDB a OMDB)
- F√°cil mockear en tests
- Rate limiting y retry logic centralizados

### 4. **tsx en lugar de ts-node**

**Raz√≥n:** 
- `ts-node` tiene problemas con ESM
- `tsx` es m√°s r√°pido y maneja ESM perfectamente
- No requiere extensiones `.js` en imports

### 5. **Supabase sobre ORM tradicional**

**Ventajas:**
- Backend-as-a-Service completo
- Cliente JavaScript nativo
- Realtime integrado
- Menos boilerplate que Prisma/TypeORM

**Trade-off:**
- Vendor lock-in (pero PostgreSQL est√°ndar debajo)

### 6. **DAO Pattern sobre Active Record**

**Raz√≥n:**
- Mejor separaci√≥n de responsabilidades
- M√°s f√°cil de testear (mocking)
- No mezcla l√≥gica de negocio con persistencia

### 7. **Arquitectura en Capas sobre Monol√≠tico**

**Raz√≥n:**
- Escalabilidad
- Mantenibilidad
- Facilita testing unitario
- Permite migrar a microservicios si es necesario

---

## üìà Escalabilidad

### Escalabilidad Horizontal

```
         Load Balancer
              ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚Üì       ‚Üì       ‚Üì
   Server1 Server2 Server3
      ‚îÇ       ‚îÇ       ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
         Supabase DB
```

**Preparaci√≥n:**
- ‚úÖ Arquitectura stateless (sin sesiones en memoria)
- ‚úÖ Variables de entorno para configuraci√≥n


### Escalabilidad de Base de Datos

**Supabase maneja:**
- Connection pooling
- Replicaci√≥n
- Backups autom√°ticos

**Futuras optimizaciones:**
- √çndices en columnas frecuentemente consultadas
- Query optimization
- Read replicas para lectura intensiva



### API Rate Limiting & Caching

**Para APIs externas (TMDB, etc.):**

```typescript
// Implementar cache para reducir llamadas a APIs
class CachedMoviesApiService extends MoviesApiService {
  private cache = new Map<string, { data: any; timestamp: number }>();
  private CACHE_TTL = 3600000; // 1 hora
  
  async getMovieDetails(movieId: string) {
    const cached = this.cache.get(`movie:${movieId}`);
    
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.data;
    }
    
    const data = await super.getMovieDetails(movieId);
    this.cache.set(`movie:${movieId}`, { data, timestamp: Date.now() });
    
    return data;
  }
}
```
---


## üîê Seguridad

### Implementadas

‚úÖ **Variables de entorno para secrets**  
‚úÖ **CORS configurado** (m√∫ltiples or√≠genes, credentials habilitados)  
‚úÖ **Express JSON body parser** (l√≠mite de 10mb)  
‚úÖ **Hash de contrase√±as** (bcrypt con 10 salt rounds)  
‚úÖ **Rate limiting** (express-rate-limit en login: 3-5 intentos/5min)  
‚úÖ **JWT authentication** (tokens con expiraci√≥n de 24h)  
‚úÖ **Validaci√≥n de input** (validaci√≥n manual en controllers)  
‚úÖ **SQL injection prevention** (Supabase maneja prepared statements)  
‚úÖ **Middleware de autenticaci√≥n** (verifica JWT en rutas protegidas)  
‚úÖ **Soft delete** (no elimina datos f√≠sicamente)  
‚úÖ **Cookie seguras** (httpOnly, secure en producci√≥n, sameSite)

### Medidas de Seguridad Espec√≠ficas

**Contrase√±as:**
- Hash con bcrypt (10 salt rounds)
- Validaci√≥n: m√≠nimo 8 caracteres, may√∫scula, min√∫scula, n√∫mero, car√°cter especial
- Never retornadas en responses

**JWT:**
- Tokens firmados con secret seguro
- Expiraci√≥n de 24h para access tokens
- Expiraci√≥n de 1h para reset password tokens
- JTI (JWT ID) √∫nico para reset tokens (previene reutilizaci√≥n)

**Rate Limiting:**
- Login: 3-5 intentos por 5 minutos
- Skip en desarrollo para facilitar testing
- Headers est√°ndar de rate limit incluidos

**CORS:**
- Lista blanca de or√≠genes permitidos
- Credentials habilitados para cookies
- En desarrollo: permite todos los or√≠genes

### Pendientes

‚ö†Ô∏è Helmet.js para headers de seguridad  
‚ö†Ô∏è Input sanitization (DOMPurify para contenido HTML)  
‚ö†Ô∏è CSRF protection  
‚ö†Ô∏è Refresh tokens (para sessions de larga duraci√≥n)  
‚ö†Ô∏è Account lockout despu√©s de m√∫ltiples intentos fallidos
---

## üìö Recursos Adicionales

- [Express Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Supabase Documentation](https://supabase.com/docs)
- [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)

---

## üìä Componentes Principales Implementados

| Componente         | Descripci√≥n                                    | Estado           |
|------------        |------------------------------------------------|------------------|
| **AuthController** | Registro, login, logout, forgot/reset password, verify auth | ‚úÖ Implementado |
| **UserController** | Perfil, actualizaci√≥n, soft delete             | ‚úÖ Implementado |
| **BaseDAO**        | CRUD gen√©rico + soft delete                    | ‚úÖ Implementado |
| **UserDAO**        | Operaciones espec√≠ficas de usuarios            | ‚úÖ Implementado |
| **Auth Middleware** | JWT verification + rate limiting              | ‚úÖ Implementado |
| **Error Handler**  | Manejo de errores Supabase/PostgreSQL          | ‚úÖ Implementado |
| **Logger Middleware** | Logging de requests/responses               | ‚úÖ Implementado |
| **NotFound Middleware** | Manejo de rutas 404                       | ‚úÖ Implementado |
| **Resend Service**  | Env√≠o de emails transaccionales               | ‚úÖ Implementado |

---

**√öltima actualizaci√≥n:** Octubre 2025  
**Versi√≥n de arquitectura:** 1.5 
**Estado:** Producci√≥n Ready (Backend Auth & User Management)

